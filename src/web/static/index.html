<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Генератор Лабиринтов и Пещер</title>
    <style>
        :root {
            --primary-bg: #1a1a1a;
            --secondary-bg: #2d2d2d;
            --accent: #7c8aff;
            --accent-hover: #6677ff;
            --text: #e0e0e0;
            --text-dim: #b0b0b0;
            --border: #404040;
            --cell-bg: #333;
            --path: #7c8aff88;
            --current: #ff6b6b;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            background-color: var(--primary-bg);
            color: var(--text);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            padding: 20px;
        }
        
        header {
            text-align: center;
            margin-bottom: 20px;
            padding: 10px;
        }
        
        h1 {
            font-size: 2.2rem;
            margin-bottom: 10px;
            background: linear-gradient(90deg, var(--accent), #a78aff);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }
        
        .subtitle {
            color: var(--text-dim);
            font-size: 1.1rem;
            max-width: 600px;
            margin: 0 auto;
        }
        
        .mode-selector {
            display: flex;
            justify-content: center;
            margin: 20px 0;
            gap: 15px;
        }
        
        .mode-btn {
            background-color: var(--secondary-bg);
            color: var(--text);
            border: 2px solid var(--border);
            padding: 10px 25px;
            border-radius: 30px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .mode-btn.active {
            background-color: var(--accent);
            border-color: var(--accent);
            color: white;
        }
        
        .mode-btn:hover:not(.active) {
            background-color: #3a3a3a;
        }
        
        .main-container {
            display: flex;
            flex-direction: column;
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
            gap: 25px;
        }
        
        .visualization {
            background-color: var(--secondary-bg);
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            min-height: 500px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        #canvas-container {
            width: 100%;
            display: flex;
            justify-content: center;
            margin-top: 15px;
        }
        
        #mazeCanvas {
            background-color: var(--cell-bg);
            border: 2px solid var(--border);
            border-radius: 8px;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 25px;
        }
        
        .control-panel {
            background-color: var(--secondary-bg);
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .panel-title {
            color: var(--accent);
            font-size: 1.3rem;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .panel-title i {
            font-size: 1.2rem;
        }
        
        .input-group {
            margin-bottom: 18px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            color: var(--text-dim);
            font-weight: 500;
        }
        
        input, select {
            width: 100%;
            padding: 12px 15px;
            background-color: #404040;
            border: 2px solid var(--border);
            border-radius: 8px;
            color: var(--text);
            font-size: 1rem;
            transition: all 0.3s ease;
        }
        
        input:focus, select:focus {
            outline: none;
            border-color: var(--accent);
            background-color: #4a4a4a;
        }
        
        .btn-group {
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px;
            margin-top: 15px;
        }
        
        button {
            background-color: var(--accent);
            color: white;
            border: none;
            padding: 13px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        button:hover {
            background-color: var(--accent-hover);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        button.secondary {
            background-color: #5a5a5a;
        }
        
        button.secondary:hover {
            background-color: #6a6a6a;
        }
        
        .solve-buttons {
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px;
            margin-top: 15px;
        }
        
        .hidden {
            display: none;
        }
        
        .info-panel {
            background-color: var(--secondary-bg);
            border-radius: 12px;
            padding: 20px;
            margin-top: 25px;
        }
        
        .info-panel h3 {
            color: var(--accent);
            margin-bottom: 12px;
        }
        
        .info-panel p {
            margin-bottom: 10px;
            line-height: 1.5;
        }
        
        footer {
            text-align: center;
            margin-top: 30px;
            padding: 20px;
            color: var(--text-dim);
            font-size: 0.9rem;
        }
        
        /* Адаптивность */
        @media (max-width: 768px) {
            .controls {
                grid-template-columns: 1fr;
            }
            
            .solve-buttons {
                grid-template-columns: 1fr;
            }
            
            .main-container {
                gap: 15px;
            }
            
            .control-panel {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Генератор Лабиринтов и Пещер</h1>
        <p class="subtitle">Создавайте, визуализируйте и исследуйте лабиринты и клеточные автоматы с помощью этого инструмента</p>
    </header>
    
    <div class="mode-selector">
        <button id="mazeModeBtn" class="mode-btn active">Лабиринт</button>
        <button id="caveModeBtn" class="mode-btn">Пещера</button>
    </div>
    
    <div class="main-container">
        <div class="visualization">
            <h2 id="visualTitle">Визуализация Лабиринта</h2>
            <div id="canvas-container">
                <canvas id="mazeCanvas"></canvas>
                <div id="initial-message" style="
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    color: #b0b0b0;
                    font-size: 1.2rem;
                    text-align: center;
                ">
                    Сгенерируйте или загрузите лабиринт/пещеру
                </div>
            </div>
        </div>
        
        <div class="controls">
            <div id="mazeControl" class="control-panel">
                <h3 class="panel-title">Управление Лабиринтом</h3>
                
                <div class="input-group">
                    <label for="rows">Количество строк:</label>
                    <input type="number" id="rows" min="5" max="50" value="15">
                </div>
                
                <div class="input-group">
                    <label for="cols">Количество столбцов:</label>
                    <input type="number" id="cols" min="5" max="50" value="15">
                </div>
                
                <div class="btn-group">
                    <button onclick="generateMaze()">
                        Сгенерировать новый лабиринт
                    </button>
                </div>
                <div class="input-group">
                    <label>Загрузить лабиринт из файла:</label>
                    <input type="file" id="mazeFileInput" accept=".txt" 
                           style="width: 100%; padding: 8px; background: #404040; border-radius: 8px; border: 1px solid #606060;"
                           onchange="loadMazeFromFile(this.files)">
                    <div id="mazeFileStatus" class="hint" style="margin-top: 5px;"></div>
                </div>
                
                <h3 class="panel-title" style="margin-top: 25px;">Решение Лабиринта</h3>
                
                <div class="input-group">
                    <label for="startX">Старт X:</label>
                    <input type="number" id="startX" min="0" value="0">
                </div>
                
                <div class="input-group">
                    <label for="startY">Старт Y:</label>
                    <input type="number" id="startY" min="0" value="0">
                </div>
                
                <div class="input-group">
                    <label for="endX">Финиш X:</label>
                    <input type="number" id="endX" min="0" value="14">
                </div>
                
                <div class="input-group">
                    <label for="endY">Финиш Y:</label>
                    <input type="number" id="endY" min="0" value="14">
                </div>
                
                <div class="solve-buttons">
                    <button onclick="solveMaze(0)">
                        Решение по левой стене
                    </button>
                    <button onclick="solveMaze(1)">
                        Решение через Q-Learning
                    </button>
                </div>
            </div>
            
            <div id="caveControl" class="control-panel hidden">
                <h3 class="panel-title">Управление Пещерой</h3>
                <div class="solve-buttons">
                    <button onclick="stepCave()">
                        Сделать шаг
                    </button>
                </div>
                
                <div class="input-group">
                    <label for="caveRows">Количество строк:</label>
                    <input type="number" id="caveRows" min="5" max="50" value="20">
                </div>
                
                <div class="input-group">
                    <label for="caveCols">Количество столбцов:</label>
                    <input type="number" id="caveCols" min="5" max="50" value="30">
                </div>
                
                <div class="input-group">
                    <label for="chance">Вероятность жизни (1-99%):</label>
                    <input type="number" id="chance" min="1" max="99" value="45">
                </div>
                
                <div class="btn-group">
                    <button onclick="generateCave()">
                        Сгенерировать пещеру
                    </button>
                    <div class="input-group">
                        <label>Загрузить пещеру из файла:</label>
                        <input type="file" id="caveFileInput" accept=".txt" 
                               style="width: 100%; padding: 8px; background: #404040; border-radius: 8px; border: 1px solid #606060;"
                               onchange="loadCaveFromFile(this.files)">
                        <div id="caveFileStatus" class="hint" style="margin-top: 5px;"></div>
                    </div>
                </div>
                
                <div id="caveError" class="error-message"></div>
                
                <h3 class="panel-title" style="margin-top: 25px;">Эволюция Пещеры</h3>
                
                <div class="input-group">
                    <label for="birthLimit">Предел рождения:</label>
                    <input type="number" id="birthLimit" min="1" max="7" value="4">
                </div>
                
                <div class="input-group">
                    <label for="deathLimit">Предел смерти:</label>
                    <input type="number" id="deathLimit" min="1" max="7" value="3">
                </div>
                

            </div>
        </div>
        
        <div class="info-panel">
            <h3>Как это работает?</h3>
            <p><strong>Лабиринты:</strong> Генерируются с использованием алгоритма Эллера. Вы можете визуализировать процесс решения двумя методами: традиционным "по левой стене" и машинным обучением через Q-Learning.</p>
            <p><strong>Пещеры:</strong> Создаются с помощью клеточных автоматов. Вы можете управлять эволюцией пещеры, настраивая пределы рождения и смерти для клеток.</p>
        </div>
    </div>
    
    <footer>
        <p>Генератор Лабиринтов и Пещер &copy; 2025 | Использует алгоритмы клеточных автоматов и поиска пути</p>
    </footer>

    <script>
        // Элементы интерфейса
        const mazeModeBtn = document.getElementById('mazeModeBtn');
        const caveModeBtn = document.getElementById('caveModeBtn');
        const mazeControl = document.getElementById('mazeControl');
        const caveControl = document.getElementById('caveControl');
        const visualTitle = document.getElementById('visualTitle');
        const canvas = document.getElementById('mazeCanvas');
        const ctx = canvas.getContext('2d');
        
        // Параметры отрисовки
        const CELL_SIZE = 25;
        let currentMode = 'maze';
        let currentSolution = null;
        let currentFloors = null;
        let currentWalls = null;
        let caveState = null;
        let hasMazeData = false;
        let hasCaveData = false;
        
        // Инициализация
        window.onload = function() {
            updateCanvasSize();
            window.addEventListener('resize', updateCanvasSize);
            showMazeMessage();
        };
        
        mazeModeBtn.addEventListener('click', function() {
        currentMode = 'maze';
        mazeModeBtn.classList.add('active');
        caveModeBtn.classList.remove('active');
        mazeControl.classList.remove('hidden');
        caveControl.classList.add('hidden');
        visualTitle.textContent = 'Визуализация Лабиринта';
        
        clearCanvas(); // Очищаем холст при переключении
        
        if (hasMazeData) {
            hideMazeMessage();
            drawMaze(currentFloors, currentWalls);
        } else {
            showMazeMessage();
        }
    });
    
    caveModeBtn.addEventListener('click', function() {
        currentMode = 'cave';
        caveModeBtn.classList.add('active');
        mazeModeBtn.classList.remove('active');
        caveControl.classList.remove('hidden');
        mazeControl.classList.add('hidden');
        visualTitle.textContent = 'Визуализация Пещеры';
        
        clearCanvas(); // Очищаем холст при переключении
        
        if (hasCaveData) {
            hideCaveMessage();
            drawCave(caveState);
        } else {
            showCaveMessage();
        }
    });

        function logFormData(formData) {
            for (const pair of formData.entries()) {
                console.log(pair[0] + ': ' + pair[1]);
            }
        }

        function logURLSearchParams(params) {
            for (const [key, value] of params.entries()) {
                console.log(key + ': ' + value);
            }
        }
        
        // Обновление размера canvas
        function updateCanvasSize() {
            const container = document.getElementById('canvas-container');
            const maxWidth = container.clientWidth - 40;
            
            if (currentMode === 'maze' && currentFloors) {
                const cols = currentFloors[0].length;
                const rows = currentFloors.length;
                canvas.width = cols * CELL_SIZE;
                canvas.height = rows * CELL_SIZE;
            } else if (currentMode === 'cave' && caveState) {
                const cols = caveState[0].length;
                const rows = caveState.length;
                canvas.width = cols * CELL_SIZE;
                canvas.height = rows * CELL_SIZE;
            } else {
                canvas.width = Math.min(500, maxWidth);
                canvas.height = 400;
            }
        }

        function updateFileName(input) {
            if (input.files.length > 0) {
                selectedFile = input.files[0];
                fileNameDisplay.textContent = selectedFile.name;
            } else {
                selectedFile = null;
                fileNameDisplay.textContent = "Файл не выбран";
            }
        }
        
        function clearCanvas() {
            const canvas = document.getElementById('mazeCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Возвращаем холст к исходным размерам
            const container = document.getElementById('canvas-container');
            const maxWidth = container.clientWidth - 40;
            canvas.width = Math.min(500, maxWidth);
            canvas.height = 400;
        }
        
        // Функция для добавления паттерна в пещеру
        function addPattern(grid, row, col, pattern) {
            for (let i = 0; i < pattern.length; i++) {
                for (let j = 0; j < pattern[i].length; j++) {
                    if (row+i < grid.length && col+j < grid[0].length) {
                        grid[row+i][col+j] = pattern[i][j];
                    }
                }
            }
        }
        
        // Отрисовка лабиринта
        function drawMaze(floors, walls) {
            const canvas = document.getElementById('mazeCanvas');
            const ctx = canvas.getContext('2d');
            
            // Очищаем canvas если нет данных
            if (!floors || !walls) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                return;
            }

            if (!floors || !walls) {
                // Если нет данных для лабиринта, показываем сообщение для лабиринта
                if (currentMode === 'maze') {
                    showMazeMessage();
                }
                return;
            }
            
            // Если есть данные и мы в режиме лабиринта, скрываем сообщение
            if (currentMode === 'maze') {
                hideMazeMessage();
            }
           
            const rows = floors.length;
            const cols = floors[0].length;
            
            // Установка размера canvas
            canvas.width = cols * CELL_SIZE;
            canvas.height = rows * CELL_SIZE;
            
            // Очистка
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#606060';
            ctx.lineWidth = 2;
            
            // Рисуем внешние границы
            ctx.beginPath();
            ctx.rect(0, 0, canvas.width, canvas.height);
            ctx.stroke();
            
            // Рисуем полы (нижние границы)
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    if (floors[y][x] === 1) {
                        ctx.beginPath();
                        ctx.moveTo(x * CELL_SIZE, (y + 1) * CELL_SIZE);
                        ctx.lineTo((x + 1) * CELL_SIZE, (y + 1) * CELL_SIZE);
                        ctx.stroke();
                    }
                }
            }
            
            // Рисуем стены (правые границы)
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    if (walls[y][x] === 1) {
                        ctx.beginPath();
                        ctx.moveTo((x + 1) * CELL_SIZE, y * CELL_SIZE);
                        ctx.lineTo((x + 1) * CELL_SIZE, (y + 1) * CELL_SIZE);
                        ctx.stroke();
                    }
                }
            }
            
        }
        
        function drawCave(grid) {
            const canvas = document.getElementById('mazeCanvas');
            const ctx = canvas.getContext('2d');
            
            // Очищаем canvas если нет данных
            if (!grid || grid.length === 0 || grid[0].length === 0) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                hideCaveError(); // Скрываем возможные ошибки
                return;
            }
            if (!grid || grid.length === 0 || grid[0].length === 0) {
                // Если нет данных для пещеры, показываем сообщение для пещеры
                if (currentMode === 'cave') {
                    showCaveMessage();
                }
                return;
            }
            
            // Если есть данные и мы в режиме пещеры, скрываем сообщение
            if (currentMode === 'cave') {
                hideCaveMessage();
            }
            
            const rows = grid.length;
            const cols = grid[0].length;
            
            // Обновляем размеры canvas
            canvas.width = cols * CELL_SIZE;
            canvas.height = rows * CELL_SIZE;
            
            // Очищаем canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Рисуем клетки
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    if (grid[y][x] === 1) {
                        ctx.fillStyle = '#7c8aff';
                        ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    } else {
                        ctx.fillStyle = '#333';
                        ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    }
                    
                    // Сетка
                    ctx.strokeStyle = '#404040';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                }
            }
            
            hideCaveError();
        }

        // Показ сообщения об ошибке
        function showCaveError(message) {
            const errorEl = document.getElementById('caveError');
            errorEl.textContent = message;
            errorEl.style.display = 'block';
        }
        
        // Скрытие сообщения об ошибке
        function hideCaveError() {
            const errorEl = document.getElementById('caveError');
            errorEl.style.display = 'none';
        }

        // Генерация пещеры с обработкой ошибок
        
        
        // Отрисовка решения
        function drawSolutionStep(solution) {
            if (!currentFloors || !currentWalls) return;
            
            const rows = currentFloors.length;
            const cols = currentFloors[0].length;
            
            // Очистка и отрисовка основы
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawMaze(currentFloors, currentWalls);
            
            // Отрисовка решения
            for (let y = 0; y < solution.length; y++) {
                for (let x = 0; x < solution[y].length; x++) {
                    if (solution[y][x] === 1) {
                        ctx.fillStyle = 'rgba(124, 138, 255, 0.5)';
                        ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    } else if (solution[y][x] === 2) {
                        ctx.fillStyle = 'rgba(255, 107, 107, 0.7)';
                        ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    }
                }
            }
        }
        
        // Анимация решения
        function animateSolution(steps) {
            let currentStep = 0;
            const animation = setInterval(() => {
                if (currentStep >= steps.length) {
                    clearInterval(animation);
                    return;
                }
                drawSolutionStep(steps[currentStep]);
                currentStep++;
            }, 100);
        }
        
        // Генерация лабиринта
        function generateMaze() {
            const rows = parseInt(document.getElementById('rows').value) || 15;
            const cols = parseInt(document.getElementById('cols').value) || 15;
            
            const formData = new FormData();
            formData.append('mode', 'random');
            formData.append('rows', rows);
            formData.append('cols', cols);

            fetch('/generate/maze', {
                method: 'POST',
                body: formData
            })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(err => {
                        throw new Error(err.error || `HTTP error ${response.status}`);
                    });
                }
                return response.json();
            })
            .then(data => {
                currentFloors = data.floors;
                currentWalls = data.walls;
                updateCoordinates(currentFloors);
                drawMaze(currentFloors, currentWalls);
            })
            .catch(error => {
                console.error('Error:', error);
                alert(`Ошибка генерации лабиринта: ${error.message}`);
            });
        }
        
        // Генерация пещеры
        function generateCave() {
            const chanceInput = document.getElementById('chance');
            console.log("Chance input value:", chanceInput.value);
            
            const rows = parseInt(document.getElementById('caveRows').value) || 20;
            const cols = parseInt(document.getElementById('caveCols').value) || 30;
            
            // Преобразуем проценты в float (0.0 - 1.0)
            const chancePercent = parseInt(document.getElementById('chance').value) || 45;
            const chance = chancePercent / 100;
            
            console.log("Parsed chance percent:", chancePercent);
            
            console.log("Calculated chance float:", chance);
            
            // Округляем до 2 знаков для безопасности
            const chanceFloat = parseFloat(chance.toFixed(2));

            const data = new URLSearchParams();
            data.append('mode', 'random');
            data.append('rows', rows);
            data.append('cols', cols);
            data.append('chance', chance);
            
            console.log("URLSearchParams content:");
            logURLSearchParams(data);

            const formData = new FormData();
            formData.append('mode', 'random');
            formData.append('rows', rows);
            formData.append('cols', cols);
            formData.append('chance', chanceFloat.toString());

            fetch(`/generate/cave?mode=random&rows=${rows}&cols=${cols}&chance=${chance}`)
            .then(response => {
                if (!response.ok) {
                    return response.json().then(err => {
                        throw new Error(err.error || `Ошибка сервера: ${response.status}`);
                    });
                }
                return response.json();
            })
            .then(data => {
                if (data.error) {
                    throw new Error(data.error);
                }
                
                // Проверка полученных данных
                if (!data.state || data.state.length === 0) {
                    throw new Error("Получены пустые данные пещеры");
                }
                
                caveState = data.state;
                console.log("Received cave data:", caveState);
                
                // Убедимся, что мы в режиме пещеры
                if (currentMode !== 'cave') {
                    caveModeBtn.click();
                }
                
                drawCave(caveState);
            })
            .catch(error => {
                console.error('Error:', error);
                showCaveError(`Ошибка генерации пещеры: ${error.message}`);
            })
            .catch(error => {
            console.error("Fetch error:", error);
            console.log("Request details:", {
                method: 'POST',
                url: '/generate/cave',
                body: formData
            });});
                }

        function stepCave() {
            const birth = parseInt(document.getElementById('birthLimit').value) || 4;
            const death = parseInt(document.getElementById('deathLimit').value) || 3;

            // Проверяем, что пещера сгенерирована
            if (!caveState) {
                alert("Сначала сгенерируйте или загрузите пещеру");
                return;
            }

            // Формируем объект с данными для отправки
            const requestData = {
                state: caveState,
                life: birth,
                death: death
            };

            fetch('/step/cave', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(requestData)
            })
            .then(response => response.json())
            .then(data => {
                caveState = data.state;
                drawCave(caveState);
            })
            .catch(error => console.error('Error:', error));
        }
        
        // Подсчет живых соседей
        function countNeighbors(grid, row, col) {
            let count = 0;
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    if (i === 0 && j === 0) continue;
                    
                    const r = row + i;
                    const c = col + j;
                    
                    if (r >= 0 && r < grid.length && c >= 0 && c < grid[0].length) {
                        count += grid[r][c];
                    }
                }
            }
            return count;
        }
        
        function solveMaze(method) {
            const startX = parseInt(document.getElementById('startX').value) || 0;
            const startY = parseInt(document.getElementById('startY').value) || 0;
            const endX = parseInt(document.getElementById('endX').value) || 14;
            const endY = parseInt(document.getElementById('endY').value) || 14;

            // Проверяем, что лабиринт сгенерирован
            if (!currentFloors || !currentWalls) {
                alert("Сначала сгенерируйте или загрузите лабиринт");
                return;
            }

            // Формируем объект с данными для отправки
            const requestData = {
                maze: {
                    rows: currentFloors.length,
                    cols: currentFloors[0].length,
                    floors: currentFloors,
                    walls: currentWalls
                },
                method: method,
                startX: startX,
                startY: startY,
                endX: endX,
                endY: endY
            };

            fetch('/solve/maze', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(requestData)
            })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(err => {
                        throw new Error(err.error || `HTTP error ${response.status}`);
                    });
                }
                return response.json();
            })
            .then(data => {
                if (method === 0) {
                    animateSolution(data.solveAlgo);
                } else {
                    drawSolutionStep(data.solveML);
                }
            })
            .catch(error => {
                console.error('Error:', error);
                alert(`Ошибка при решении лабиринта: ${error.message}`);
            });
        }
        
        let selectedCaveFile = null;

        // Обновляем отображение имени файла при выборе
        document.getElementById('caveFileInput').addEventListener('change', function(e) {
            if (e.target.files.length > 0) {
                selectedCaveFile = e.target.files[0];
                document.getElementById('fileNameDisplay').textContent = selectedCaveFile.name;
            } else {
                selectedCaveFile = null;
                document.getElementById('fileNameDisplay').textContent = "Файл не выбран";
            }
        });

        function loadCaveFromFile(files) {
            if (!files || files.length === 0) {
                document.getElementById('caveFileStatus').textContent = "Файл не выбран";
                return;
            }
            
            const file = files[0];
            document.getElementById('caveFileStatus').textContent = `Загрузка ${file.name}...`;
            
            const formData = new FormData();
            formData.append('mode', 'file');
            formData.append('file', file);

            fetch('/generate/cave', {
                method: 'POST',
                body: formData
            })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(err => {
                        throw new Error(err.error || `HTTP error ${response.status}`);
                    });
                }
                return response.json();
            })
            .then(data => {
                if (data.error) {
                    throw new Error(data.error);
                }
                
                caveState = data.state;
                document.getElementById('caveFileStatus').textContent = `Файл ${file.name} успешно загружен`;
                
                if (currentMode !== 'cave') {
                    caveModeBtn.click();
                }
                
                drawCave(caveState);
            })
            .catch(error => {
                console.error('Error:', error);
                document.getElementById('caveFileStatus').textContent = `Ошибка: ${error.message}`;
                showCaveError(`Ошибка загрузки файла: ${error.message}`);
            });
        }

        function updateCoordinates(floors) {
            if (!floors || floors.length === 0) return;
            
            const rows = floors.length;
            const cols = floors[0].length;
            
            // Устанавливаем старт (0,0) и финиш (последняя ячейка)
            document.getElementById('startX').value = 0;
            document.getElementById('startY').value = 0;
            document.getElementById('endX').value = cols - 1;
            document.getElementById('endY').value = rows - 1;
        }

        function loadMazeFromFile(files) {
            if (!files || files.length === 0) {
                document.getElementById('mazeFileStatus').textContent = "Файл не выбран";
                return;
            }
            
            const file = files[0];
            document.getElementById('mazeFileStatus').textContent = `Загрузка ${file.name}...`;
            
            const formData = new FormData();
            formData.append('mode', 'file');
            formData.append('file', file);

            fetch('/generate/maze', {
                method: 'POST',
                body: formData
            })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(err => {
                        throw new Error(err.error || `HTTP error ${response.status}`);
                    });
                }
                return response.json();
            })
            .then(data => {
                if (data.error) {
                    throw new Error(data.error);
                }
                
                currentFloors = data.floors;
                currentWalls = data.walls;
                document.getElementById('mazeFileStatus').textContent = `Файл ${file.name} успешно загружен`;
                
                // Автоматически обновляем координаты старта и финиша
                updateCoordinates(currentFloors);
                
                if (currentMode !== 'maze') {
                    mazeModeBtn.click();
                }
                
                drawMaze(currentFloors, currentWalls);
            })
            .catch(error => {
                console.error('Error:', error);
                document.getElementById('mazeFileStatus').textContent = `Ошибка: ${error.message}`;
                alert(`Ошибка загрузки файла: ${error.message}`);
            });
        }
        // Функции для управления сообщениями
        function showMazeMessage() {
            const message = document.getElementById('initial-message');
            message.textContent = "Сгенерируйте или загрузите лабиринт";
            message.style.display = 'block';
        }

        function hideMazeMessage() {
            const message = document.getElementById('initial-message');
            message.style.display = 'none';
        }

        function showCaveMessage() {
            const message = document.getElementById('initial-message');
            message.textContent = "Сгенерируйте или загрузите пещеру";
            message.style.display = 'block';
        }

        function hideCaveMessage() {
            const message = document.getElementById('initial-message');
            message.style.display = 'none';
        }

    </script>
</body>
</html>